#summary Developer guide for creating new components.
#labels Featured,Phase-Implementation

===General advice===

*When making a new component make sure to look around and be consistent with what's already there. This applies to component appearance, behavior but also the code. It is important to keep the visual identity and user experience consistent across the board and to have a maintainable code base that follows the same coding standards and patterns. Good luck.*

===Prerequisites===

  # [http://www.oracle.com/technetwork/java/javase/downloads/index.html JDK or JRE] 1.6.0_10 or newer installed.
  # Some Java IDE, preferably [http://www.eclipse.org/ Eclipse].
  # SVN client, [http://subclipse.tigris.org/ Subclipse] is recommended if you're using Eclipse. Follow [http://code.google.com/p/diy-layout-creator/source/checkout this guide] to learn how to checkout the project from the source control.
  # Decent knowledge of Java language, in specific [http://java.sun.com/j2se/1.5/pdf/generics-tutorial.pdf generics], [http://download.oracle.com/javase/tutorial/java/javaOO/annotations.html annotations] and [http://download.oracle.com/javase/tutorial/2d/overview/index.html Graphics2D]. Unlike the previous version, you actually need to write Java code to make the component look and behave the way you want it. This makes it harder for non-programmers to make their own components or customize existing ones, but it allows greater flexibility and performance.

===Adding to the main library===

  # Checkout *DIYLC* and *Library* folders from the SVN.
  # New components should be created inside *org.diylc.components* package.
  # When you are done developing and testing the new components, build the project into *DIYLC/library/main.jar*.
  # Commit new classes to the source control.
  # Commit the updated library/main.jar back to the source control.

===Creating your own component library===

  # Create a new Java project.
  # Add *diylc.jar* to the dependencies.
  # Since it's your own project, you can use whichever package name you like.
  # When you are done developing and testing the new components, build your project as jar file.
  # To add your components to the DIYLC project commit your new jar to *library* folder in the DIYLC source control. It should be automatically recognized by the app.

===Component API===

In order for a component to be recognized by the application it has to meet the following:

  * It must implement (directly or indirectly) *`IDIYComponent`* component interface. It is advisable, whenever possible, to extends one of the abstract classes instead of making a component from scratch. See below the list of them and more details.
  * Class parameter is type of component value. For instance, resistor will have it's value type set to `Resistance` and IC will have the type of `String` (to designate IC code)
  * It is not mandatory but highly recommended to annotate each component class with *`@ComponentDescriptor`* annotation. Application will recognize and install the component even without it, but you will be unable to configure all the aspects of a component and they will be defaulted to values that are potentially unsuitable for the component.
  * All component properties should be annotated with *`@EditableProperty`* annotation.
  * It should be compiled, packed inside a jar and placed in *library* folder.

====`@ComponentDescriptor` annotation====

May be applied only to classes that implement `IDIYComponent` interface. Contains the following attributes:

  * *name*: name of component type, e.g. "Resistor". This will be shown in the toolbox
  * *description*: one or two sentence description of the component. Will be shown in the tooltip over toolbox buttons
  * *author*: name of the developer who wrote the component
  * *instanceNamePrefix*: prefix that will be used to generate component instance names, e.g. "R" for resistors or "Q" for transistors. Application will append the index automatically to form component instance names, such as "Q1"
  * *zOrder*: Z-order of the component, lower number meaning that component will be shown in the back. `IDIYComponent` lists major layers, but you can use any double number. Sometimes it's useful to add a small offset to an existing zOrder. For instance, solder pads and copper traces belong to the same layer but pads should be always rendered above traces to show the hole correctly. That's why it's zOrder is increased for 0.1.
  * *stretchable*: when false, moving one control point will cause all the others to move together with it, default is `true`

Sample usage:
{{{
@ComponentDescriptor(name = "Resistor", author = "Branislav Stojkovic", category = "Passive", instanceNamePrefix = "R",
                     description = "Resistor layout symbol", zOrder = IDIYComponent.COMPONENT)
public class Resistor extends AbstractLeadedDIYComponent<Resistance> {
}}}

====`@EditableProperty` annotation====

May be applied only to component a property getter that has a matching setter. Below is the list of supported property types:

  * *Byte* and *byte*: create a slider that has range from 0 to 127.
  * *Color*: creates a colored panel that opens the color picker when clicked.
  * *Enum*: creates a combo box with all values from the enum.
  * *Measure*: creates a text field and combo box that edit measure value and units respectively. See the section that explains measures for more details.
  * *String*: creates a text field.

====`AbstractTransparentComponent` class====

Base class for all components that may be transparent. Defines component name and alpha level ranging from 1 to 127. It is up to the component to use the protected byte field `alpha` when drawing.

====`AbstractSinglePointComponent` class====

Base class for components having only one control point.

====`AbstractLeadedDIYComponent` class====

This class should be used as a base class for all components that have two flying leads and solid color body that may be represented with a `Shape` object, e.g. resistor or capacitor layout symbols. It extends `AbstractTransparentComponent` and adds common logic that makes it easier to create similar components. It has the following features:

  * Draws leads automatically
  * Allows user to choose component body width and height
  * Defines two control points for lead ends
  * Defines component name and allows for editing
  * Positions and draws component body based on component location on the canvas

Child classes should implement the following methods:

  * *`getDefaultWidth`* and *`getDefaultHeight`* are used to determine default component body size. Note that users may change this later; do not use these when creating body shape.
  * *`getBodyColor`* and *`getBorderColor`* are used to determine colors for body and body border.
  * *`getBodyShape`* should return a `Shape` object that represents component body, e.g. rectangle for resistors or ellipse for ceramic capacitors. Shape should include the current component size into account, as specified in protected fields `width` and `height`. Shape should *not* include component placement into account and should be not be scaled or rotated. Also, the minimum bounding rectangle of the shape should have it's top left corner at point (0, 0). This is important because abstract class relies on that fact when drawing the component body on the canvas.

====`AbstractCurvedComponent` class====

This class should be used as a base class for all components that may be represented by a cubic (Bezier) curve. It extends `AbstractTransparentComponent` and adds 4 control points - two for start/end and two curve control points. Also, it defines the component name, allows the user to edit component color and draws 3 guidelines. It's up to the child class to draw the `CubicCurve2D` object and to provide the default color.